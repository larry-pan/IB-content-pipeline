{"messages":[{"role":"System","content":"You are an assistant that generates IB-style Computer Science questions and markschemes. Topics and subtopics are:\nSystem Fundamentals: Systems in organizations, System design basics\nComputer Organization: Computer organization\nNetworks:\nNetworks\nComputational Thinking, Problem-solving and Programming: General principles, Connecting computational thinking and program design, \nIntroduction to programming  \nAbstract Data Structures: Abstract data structures \nResource Management:\nResource management  \nControl: Control\nEach subquestion may test different topics than the main topic, so combine different topics. All coding questions should be in pseudocode. You will generate a JSON object containing the string 'question' and the list called 'options', where each element is a subquestion. Each sub-question must have:\n  - 'question': General info that introduces the subquestions.\n  - 'content': a clear and challenging question string that tests of one or more\n  - 'marks': how many marks the question is worth, with more marks for questions requiring deeper analysis or discussion.\n  - 'markscheme': an IB-style markscheme string that shows acceptable answers with mark allocations in the format 'Award [X max]' followed by bullet points of acceptable responses, using semicolons to separate alternative answers and including specific technical terminology.\n  - 'subtopics': a list of relevant subtopics that the subquestion covers."},{"role":"User","content":"System Fundamentals"},{"role":"Chatbot","content":"topic: System design basics\nparts: [{\"content\": \"Define what is meant by a real-time system and give one example.\", \"marks\": 2, \"markscheme\": \"Award [2 max]\\nDefinition:\\nA system that must respond to inputs within a guaranteed time frame;\\nProcessing must be completed within strict deadlines;\\nTiming constraints are critical to system function;\\nExample:\\nAir traffic control system;\\nMedical monitoring equipment;\\nAutomotive braking systems;\\nIndustrial process control;\\n[2]\", \"subtopics\": [\"System design basics\"], \"order\": 1}, {\"content\": \"Outline three factors that should be considered when selecting hardware for a database server in a multinational corporation.\", \"marks\": 3, \"markscheme\": \"Award [3 max]\\nProcessing power/CPU speed for handling multiple queries;\\nMemory capacity/RAM for caching frequently accessed data;\\nStorage capacity and speed for database files;\\nNetwork connectivity/bandwidth for remote access;\\nReliability/fault tolerance for continuous operation;\\nScalability for future expansion;\\nSecurity features for data protection;\\n[3]\", \"subtopics\": [\"Systems in organizations\", \"System design basics\"], \"order\": 2}, {\"content\": \"Evaluate the effectiveness of using cloud-based systems versus on-premises systems for a small educational institution.\", \"marks\": 8, \"markscheme\": \"Award [8 max]\\nCloud-based advantages:\\nLower initial costs/no hardware investment;\\nAutomatic updates and maintenance;\\nScalability based on demand;\\nAccessibility from multiple locations;\\nBuilt-in backup and disaster recovery;\\nCloud-based disadvantages:\\nOngoing subscription costs;\\nDependency on internet connectivity;\\nLess control over data security;\\nPotential vendor lock-in;\\nOn-premises advantages:\\nFull control over data and security;\\nNo ongoing subscription fees;\\nNo dependency on external internet;\\nCustomization possibilities;\\nOn-premises disadvantages:\\nHigh initial setup costs;\\nRequires technical expertise;\\nMaintenance responsibilities;\\nLimited scalability;\\nConclusion:\\nFor small educational institutions, cloud solutions often more cost-effective;\\nDecision depends on budget, technical expertise, and security requirements;\\n[8]\", \"subtopics\": [\"Systems in organizations\", \"System design basics\"], \"order\": 3}]"},{"role":"User","content":"Computer Organization"},{"role":"Chatbot","content":"topic: Computer organization\nparts: [{\"content\": \"Identify two types of computer memory that are non-volatile.\", \"marks\": 2, \"markscheme\": \"Award [2 max]\\nROM (Read-Only Memory);\\nFlash memory/SSD;\\nHard disk drive/HDD;\\nOptical storage (CD/DVD/Blu-ray);\\nMagnetic tape;\\nEEPROM;\\n[2]\", \"subtopics\": [\"Computer organization\"], \"order\": 1}, {\"content\": \"Describe the role of cache memory in improving CPU performance.\", \"marks\": 4, \"markscheme\": \"Award [4 max]\\nStores frequently accessed data/instructions;\\nLocated closer to CPU than main memory;\\nProvides faster access times than RAM;\\nReduces number of memory access cycles;\\nUses locality of reference principle;\\nMultiple levels (L1, L2, L3) with different speeds;\\nHit ratio determines effectiveness;\\n[4]\", \"subtopics\": [\"Computer organization\"], \"order\": 2}, {\"content\": \"Analyze how the von Neumann architecture differs from Harvard architecture in terms of memory organization and performance implications.\", \"marks\": 6, \"markscheme\": \"Award [6 max]\\nvon Neumann architecture:\\nSingle memory space for both instructions and data;\\nShared bus system for memory access;\\nSimpler design and implementation;\\nPotential bottleneck (von Neumann bottleneck);\\nHarvard architecture:\\nSeparate memory spaces for instructions and data;\\nSeparate buses for instruction and data access;\\nCan fetch instructions and data simultaneously;\\nBetter performance for certain applications;\\nPerformance implications:\\nHarvard allows parallel memory access;\\nvon Neumann may have memory access conflicts;\\nModern processors use modified Harvard architecture;\\n[6]\", \"subtopics\": [\"Computer organization\"], \"order\": 3}]"},{"role":"User","content":"Networks"},{"role":"Chatbot","content":"topic: Networks\nparts: [{\"content\": \"State what is meant by network latency.\", \"marks\": 1, \"markscheme\": \"Award [1 max]\\nThe time delay for data to travel from source to destination;\\nTime taken for a signal to travel across the network;\\nDelay in network communication;\\n[1]\", \"subtopics\": [\"Networks\"], \"order\": 1}, {\"content\": \"Explain how the OSI model facilitates network communication between different systems.\", \"marks\": 5, \"markscheme\": \"Award [5 max]\\nProvides standardized framework/reference model;\\nDivides network communication into seven layers;\\nEach layer has specific functions and protocols;\\nLayers interact only with adjacent layers;\\nEncapsulation/decapsulation at each layer;\\nAllows interoperability between different vendors;\\nSimplifies troubleshooting and network design;\\nExamples: Physical, Data Link, Network, Transport layers;\\n[5]\", \"subtopics\": [\"Networks\"], \"order\": 2}, {\"content\": \"Compare the advantages and disadvantages of IPv4 and IPv6 addressing schemes for modern internet infrastructure.\", \"marks\": 6, \"markscheme\": \"Award [6 max]\\nIPv4 advantages:\\nWidely supported and implemented;\\nSimpler address format (32-bit);\\nEstablished infrastructure and tools;\\nIPv4 disadvantages:\\nLimited address space (4.3 billion addresses);\\nRequires NAT for address conservation;\\nSecurity features not built-in;\\nIPv6 advantages:\\nVast address space (128-bit addresses);\\nBuilt-in security features (IPSec);\\nBetter support for mobile devices;\\nImproved routing efficiency;\\nIPv6 disadvantages:\\nSlower adoption rate;\\nCompatibility issues with IPv4;\\nMore complex configuration;\\nConclusion:\\nIPv6 necessary for future internet growth;\\nTransition period requires dual-stack implementation;\\n[6]\", \"subtopics\": [\"Networks\"], \"order\": 3}]"},{"role":"User","content":"Computational Thinking, Problem-solving and Programming"},{"role":"Chatbot","content":"topic: Connecting computational thinking and program design\nparts: [{\"content\": \"State two characteristics of good algorithm design.\", \"marks\": 2, \"markscheme\": \"Award [2 max]\\nCorrectness/produces correct output;\\nEfficiency/optimal use of resources;\\nClarity/easy to understand and follow;\\nGenerality/works for different inputs;\\nFiniteness/terminates in finite steps;\\nDefiniteness/each step clearly defined;\\n[2]\", \"subtopics\": [\"General principles\", \"Connecting computational thinking and program design\"], \"order\": 1}, {\"content\": \"Construct a pseudocode algorithm that finds the largest and smallest values in an array of 20 integers.\", \"marks\": 5, \"markscheme\": \"Award [5 max]\\nAward [1] for correct array declaration/initialization\\nAward [1] for initializing largest and smallest variables\\nAward [1] for correct loop structure\\nAward [1] for comparison to find largest\\nAward [1] for comparison to find smallest\\nExample:\\nARRAY[20] = input_values()\\nLARGEST = ARRAY[0]\\nSMALLEST = ARRAY[0]\\nloop INDEX from 1 to 19\\n  if ARRAY[INDEX] > LARGEST then\\n    LARGEST = ARRAY[INDEX]\\n  end if\\n  if ARRAY[INDEX] < SMALLEST then\\n    SMALLEST = ARRAY[INDEX]\\n  end if\\nend loop\\noutput LARGEST, SMALLEST\\n[5]\", \"subtopics\": [\"Introduction to programming\", \"General principles\"], \"order\": 2}, {\"content\": \"Discuss how pattern recognition and abstraction work together to solve complex computational problems.\", \"marks\": 4, \"markscheme\": \"Award [4 max]\\nPattern recognition:\\nIdentifies similarities and regularities in problems;\\nRecognizes recurring themes and structures;\\nHelps classify problems into known categories;\\nAbstraction:\\nRemoves unnecessary details and complexity;\\nFocuses on essential features and relationships;\\nCreates general solutions from specific cases;\\nWorking together:\\nPatterns help identify what to abstract;\\nAbstraction makes patterns more generalizable;\\nEnables reuse of solutions across similar problems;\\nFacilitates development of algorithms and data structures;\\n[4]\", \"subtopics\": [\"General principles\", \"Connecting computational thinking and program design\"], \"order\": 3}]"},{"role":"User","content":"Abstract Data Structures"},{"role":"Chatbot","content":"topic: Abstract data structures\nparts: [{\"content\": \"State the access principle used by a queue data structure.\", \"marks\": 1, \"markscheme\": \"Award [1 max]\\nFirst In First Out (FIFO);\\nFirst In Last Out (FILO);\\n[1]\", \"subtopics\": [\"Abstract data structures\"], \"order\": 1}, {\"content\": \"Describe how a binary search tree maintains its ordering property and explain one advantage of this organization.\", \"marks\": 4, \"markscheme\": \"Award [4 max]\\nOrdering property:\\nLeft subtree contains values less than parent node;\\nRight subtree contains values greater than parent node;\\nProperty maintained recursively throughout tree;\\nInsertion and deletion preserve ordering;\\nAdvantage:\\nEfficient searching with O(log n) average time complexity;\\nIn-order traversal produces sorted sequence;\\nEfficient insertion and deletion operations;\\n[4]\", \"subtopics\": [\"Abstract data structures\"], \"order\": 2}, {\"content\": \"Evaluate the suitability of different data structures (array, linked list, hash table) for implementing a student database that requires frequent searching by student ID.\", \"marks\": 7, \"markscheme\": \"Award [7 max]\\nArray implementation:\\nAdvantages: simple implementation, direct access by index;\\nDisadvantages: searching requires O(n) time if unsorted, fixed size;\\nRequires linear search unless sorted;\\nLinked list implementation:\\nAdvantages: dynamic size, efficient insertion/deletion;\\nDisadvantages: O(n) search time, no random access;\\nSequential access only makes searching slow;\\nHash table implementation:\\nAdvantages: O(1) average search time, efficient for lookups;\\nDynamic sizing possible;\\nDisadvantages: potential hash collisions, more complex implementation;\\nMemory overhead for hash function;\\nConclusion:\\nHash table most suitable for frequent searching by ID;\\nProvides best time complexity for search operations;\\nArray acceptable if sorted with binary search;\\n[7]\", \"subtopics\": [\"Abstract data structures\"], \"order\": 3}]"},{"role":"User","content":"Resource Management"},{"role":"Chatbot","content":"topic: Resource management\nparts: [{\"content\": \"Identify one method used to prevent deadlock in operating systems.\", \"marks\": 1, \"markscheme\": \"Award [1 max]\\nResource ordering/numbering;\\nTimeout mechanisms;\\nDeadlock detection and recovery;\\nBanker's algorithm;\\nPreemption of resources;\\n[1]\", \"subtopics\": [\"Resource management\"], \"order\": 1}, {\"content\": \"Explain how virtual memory allows programs larger than physical memory to execute.\", \"marks\": 4, \"markscheme\": \"Award [4 max]\\nDivides program into pages/segments;\\nOnly required pages loaded into physical memory;\\nUnused pages stored on secondary storage (swap file);\\nPage faults trigger loading from disk when needed;\\nOldest/least recently used pages swapped out;\\nMemory management unit handles address translation;\\nCreates illusion of larger memory space;\\n[4]\", \"subtopics\": [\"Resource management\"], \"order\": 2}, {\"content\": \"Analyze the performance implications of different CPU scheduling algorithms in a multi-user environment.\", \"marks\": 6, \"markscheme\": \"Award [6 max]\\nFirst Come First Served (FCFS):\\nSimple implementation but may cause convoy effect;\\nLong processes delay shorter ones;\\nPoor average waiting time;\\nRound Robin:\\nFair time allocation to all processes;\\nGood response time for interactive systems;\\nTime slice size affects performance;\\nShortest Job First (SJF):\\nOptimal average waiting time;\\nDifficult to predict execution times;\\nMay cause starvation of long processes;\\nPriority Scheduling:\\nImportant processes get preference;\\nRisk of priority inversion and starvation;\\nConclusion:\\nChoice depends on system requirements;\\nMulti-user systems often use round robin or priority-based;\\n[6]\", \"subtopics\": [\"Resource management\"], \"order\": 3}]"},{"role":"User","content":"Control"},{"role":"Chatbot","content":"topic: Control\nparts: [{\"content\": \"Define what is meant by a control system.\", \"marks\": 1, \"markscheme\": \"Award [1 max]\\nA system that manages/regulates the behavior of other systems;\\nSystem that maintains desired output through input manipulation;\\nSystem that uses feedback to control processes;\\n[1]\", \"subtopics\": [\"Control\"], \"order\": 1}, {\"content\": \"Distinguish between open-loop and closed-loop control systems, giving one example of each.\", \"marks\": 4, \"markscheme\": \"Award [4 max]\\nOpen-loop system:\\nNo feedback mechanism;\\nOutput does not influence input;\\nCannot correct for disturbances;\\nExample: microwave timer, washing machine cycle;\\nClosed-loop system:\\nUses feedback from output;\\nCompares actual output with desired output;\\nAdjusts input based on error;\\nExample: thermostat, cruise control;\\n[4]\", \"subtopics\": [\"Control\"], \"order\": 2}, {\"content\": \"Construct a pseudocode algorithm for an automatic irrigation system that waters plants based on soil moisture levels and weather conditions.\", \"marks\": 6, \"markscheme\": \"Award [6 max]\\nAward [1] for reading soil moisture sensor\\nAward [1] for reading weather/rain sensor\\nAward [1] for appropriate moisture threshold condition\\nAward [1] for checking weather conditions\\nAward [1] for controlling irrigation system\\nAward [1] for appropriate delay/timing\\nExample:\\nloop\\n  MOISTURE = read_soil_sensor()\\n  RAIN = read_rain_sensor()\\n  TIME = get_current_time()\\n  if MOISTURE < 30 AND RAIN = false AND TIME between 6am and 8pm then\\n    turn_on_irrigation()\\n    wait(30_minutes)\\n    turn_off_irrigation()\\n  end if\\n  wait(1_hour)\\nend loop\\n[6]\", \"subtopics\": [\"Control\"], \"order\": 3}]}]}"}]}